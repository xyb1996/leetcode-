"""
题目描述
小招喵某日闲来无事，想验一下自己的人品，于是给自己定了一个游戏规则：
这个游戏有三个因素：N，K，W
游戏开始的时候小招喵有0点，之后如果发现自己手上的点不足K点，就随机从1到W的整数中抽取一个（包含1和W），抽到哪个数字的概率都是相同的。
重复上述过程，直到小招喵获得了K或者大于K点，就停止获取新的点，这时候小招喵手上的点小于等于N的概率是多少？

输入：N = 5， K = 1， W = 5
输出：1.00000
说明：开始有0点，不足1点，从[1,5]中随机取一个整数（一共5个数字，所以每个数字取到的概率都是1/5），获得后得分无论如何都大于了1点，停止，概率为1

输入：N = 6， K = 1， W = 10
输出：0.60000
说明：开始有0点，不足1点，从[1,10]中随机取一个整数（一共10个数字，所以每个数字取到的概率都是1/10），获得后有6/10的概率小于6点，且满足大于1点的条件，概率为0.6
输入描述:
输入为3个整数，分别对应N，K，W，中间用空格隔开

其中0 <= K <= N <= 10000，1 <= W <= 10000
输出描述:
输出为概率值，保留5位小数

"""

"""
思路：这里的概率的意思是，首先当前手上的牌的和没有k，然后随机从1-m中抽取一个数，然后所有手上的数字加起来小于等于n的概率是多少

解法：用动态规划的方法求解，dp[i]表示上一个初始状态为i时，满足题目要求的概率值，是一道从后往前递推的dp问题
不会了可以去看链接 https://blog.csdn.net/weixin_42564710/article/details/98942203
"""

n,k,w = [int(i) for i in input().split()]
#状态可能的最大值为k-1+w
dp = [0]*(k+w)

#初始状态集合，i在[k,n],概率为1，在[n+1,k+n-1]值概率为0

for i in range(k,n+1):
	dp[i] =1
s=min(n-k+1,w)
#初始状态为i-1是，可以选择从1-k-i+1范围内的所有数
for i in range(k-1,-1,-1):
	#表示总共有w个选择，但有效概率为s个
	#这里的s是w项dp值求和，递归求前面一项的时候只需要加上dp[i]-dp[i+w]，即可
	dp[i] = s / w
	#概率值是该状态i后面的w个概率的平均
	s += dp[i] -dp[i+w]
print(round(dp[0],5))