1、查找和排序：

（1）如果要求在排序数组中查找一个数字或统计某数字出现的次数，用二分查找算法 

2、回溯算法：

3、动态规划和贪婪算法：

 一个问题可以分解成若干个子问题，并且子问题之间有重叠的更小的子问题，可以用动态规划解决。

+  动态规划算法特点： (1)求最值(2)可分解为若干子问题(3)从上往下分析问题,从下往上求解问题.

   (4)应用动态规划是,每一步可能面临若干选择.

+ 例子:面试题14
剪绳子：一个长n的绳子，剪成m段，怎么剪可以是他们的乘积最大。

   典型的动态规划问题：f(n) = max(f(i)*f(n-i)),1<=i<=n-1,注意从底往上遍历。
   或者更好的贪婪算法：当n>=5时，总是剪长度为3的，n =4时，剪两个长度为2的，n=3时剪成2,1
   
 
 <font color=#0099ff > 面试题15：二进制中1的个数：我们把一个整数和它减去1的整数做位运算，得到的结果相关与把整数的二进制中最右边
 的1变成0 000 </font>
 
 面试题16：数值的整数方：
 
 在求数的n次方相关题目时，有下面公式，可以提升效率：
 
 a^n = (a^(n /2))^2,if n == 偶数,否则为(a^(n /2))^2*a,
 另外可以用 if number & 0x1来判断一个数是偶数还是奇数，因为位运算总是效率很高的
 
 面试题17：打印从1到最大的n位数：
 注意一般大数都考虑用字符串取存储，全排列的数字可以考虑用递归去写，更简洁。
 
 面试题18：一个小trick：给定一个单链表以及一个指针，如何用O（1）时间删除该节点
   
 我们很容易得到待删除节点的下一个节点，将下一个节点的值复制到该节点中，并将下一个节点删掉即可。如果该
 节点是链表中最后一个节点，则还是需要从头至尾遍历删掉。这些都建立在待删除节点确实在链表中。
 
 面试题22：链表中倒数第k个节点：没什么说的，肯定用双指针去遍历，需要注意细节：
 （1）如果传入指针为空（2）k大于链表个数（3）k = 0 
 
 面试题24：反转链表：
 思路：用三个指针Ppre、P、Pnext来指向当前节点的前一个节点、当前节点、后一个节点进行遍历就ok了。
 
 面试题26：一个树中是否包含另一个子树结构：
 
 首先利用遍历判断一个树的根节点是否和另一个树相同，相同再递归的判断其左子树和右子树是否相同。
 
 面试题27：二叉树的镜像
 
 思路：可以前序遍历，递归地交换二叉树的左右子节点。
 
 面试题28：对称的二叉树：
 利用前序遍历（根左右）和对称的前序遍历（根右左）看两个遍历是否相同，要考虑遍历时候遇到的
 空指针。
 
 面试题30：包含min函数的栈：在栈的数据结构中实现用O（1）得到栈中元素的min。
 思路：定义两个栈，一个数据栈，一个辅助栈（用来存每一步的最小值的栈）
 
 面试题31：栈的压入和弹出序列：（1）构造一个辅助栈用来模拟进出栈过程。（2）如果当前辅助栈顶元素等于
 出栈序列的元素，则弹出辅助站，(3)否则取压入栈中取逐个入栈，知道出栈的和出栈的栈顶元素
 相等，如果压栈序列为空了，且仍没找到，则表示该序列不可能是一个弹出序列。
   
 面试题33：二叉搜索树的后续遍历序列：
 给定一个数组和长度，判断该数组会不会是某二叉搜索树的后序遍历结果。
 
 思路：数组的最后一个元素是根节点，左边的值都小于它，后边的值都大于它，然后递归的进行判断
 
 面试题34：二叉树中和为某一值的路径：
 
 思路：采用前序遍历的方法，每次先判断该节点是否是叶子节点并且路径累加和
是否=目标值，否则，前序遍历左子节点，右子节点。然后退出该节点时，需要将该
节点从路径栈中删除。

#分而治之的思想：
面试题35：复杂链表的复制
一个链表即每个节点中即有next指针，同时又一个sibling指针，指向一个随机节点。

思路：首先在每个节点后面复制一个节点，然后，然后连接sibling节点，因为若s = N.sibling，则
s.next（s'）.sibling = n.next(n')第三部就是分解两个链表了。
该方法很好。

然后一种另外思路就是构建一个（n，n'）和（s，s'）的哈希表，这样n'的sibling指向就是s'，该节点存在了哈希表中。

面试题36：二叉搜索树与双向链表
将一个二叉搜索树转换成一个双向链表

思路：采用中序遍历的思想，用一个指针记录遍历序列的最后一个节点，在中序处理中
将该节点的right指针指向该节点，同时将该节点的left指向它，然后递归的遍历左子树和
右子树即可。
最后从last节点从左至右的去遍历该双向链表并返回头结点。