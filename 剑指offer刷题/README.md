1、查找和排序：

（1）如果要求在排序数组中查找一个数字或统计某数字出现的次数，用二分查找算法 

2、回溯算法：

3、动态规划和贪婪算法：

 一个问题可以分解成若干个子问题，并且子问题之间有重叠的更小的子问题，可以用动态规划解决。

+  动态规划算法特点： (1)求最值(2)可分解为若干子问题(3)从上往下分析问题,从下往上求解问题.

   (4)应用动态规划是,每一步可能面临若干选择.

+ 例子:面试题14
剪绳子：一个长n的绳子，剪成m段，怎么剪可以是他们的乘积最大。

   典型的动态规划问题：f(n) = max(f(i)*f(n-i)),1<=i<=n-1,注意从底往上遍历。
   或者更好的贪婪算法：当n>=5时，总是剪长度为3的，n =4时，剪两个长度为2的，n=3时剪成2,1
   
 
 <font color=#0099ff > 面试题15：二进制中1的个数：我们把一个整数和它减去1的整数做位运算，得到的结果相关与把整数的二进制中最右边
 的1变成0 000 </font>
 
 面试题16：数值的整数方：
 
 在求数的n次方相关题目时，有下面公式，可以提升效率：
 
 a^n = (a^(n /2))^2,if n == 偶数,否则为(a^(n /2))^2*a,
 另外可以用 if number & 0x1来判断一个数是偶数还是奇数，因为位运算总是效率很高的
 
 面试题17：打印从1到最大的n位数：
 注意一般大数都考虑用字符串取存储，全排列的数字可以考虑用递归去写，更简洁。
 
 面试题18：一个小trick：给定一个单链表以及一个指针，如何用O（1）时间删除该节点
   
 我们很容易得到待删除节点的下一个节点，将下一个节点的值复制到该节点中，并将下一个节点删掉即可。如果该
 节点是链表中最后一个节点，则还是需要从头至尾遍历删掉。这些都建立在待删除节点确实在链表中。
 
 面试题22：链表中倒数第k个节点：没什么说的，肯定用双指针去遍历，需要注意细节：
 （1）如果传入指针为空（2）k大于链表个数（3）k = 0 
 
 面试题24：反转链表：
 思路：用三个指针Ppre、P、Pnext来指向当前节点的前一个节点、当前节点、后一个节点进行遍历就ok了。
 
 面试题26：一个树中是否包含另一个子树结构：
 
 首先利用遍历判断一个树的根节点是否和另一个树相同，相同再递归的判断其左子树和右子树是否相同。
 
 面试题27：二叉树的镜像
 
 思路：可以前序遍历，递归地交换二叉树的左右子节点。
 
 面试题28：对称的二叉树：
 利用前序遍历（根左右）和对称的前序遍历（根右左）看两个遍历是否相同，要考虑遍历时候遇到的
 空指针。
 
 面试题30：包含min函数的栈：在栈的数据结构中实现用O（1）得到栈中元素的min。
 思路：定义两个栈，一个数据栈，一个辅助栈（用来存每一步的最小值的栈）
 
 面试题31：栈的压入和弹出序列：（1）构造一个辅助栈用来模拟进出栈过程。（2）如果当前辅助栈顶元素等于
 出栈序列的元素，则弹出辅助站，(3)否则取压入栈中取逐个入栈，知道出栈的和出栈的栈顶元素
 相等，如果压栈序列为空了，且仍没找到，则表示该序列不可能是一个弹出序列。
   
 面试题33：二叉搜索树的后续遍历序列：
 给定一个数组和长度，判断该数组会不会是某二叉搜索树的后序遍历结果。
 
 思路：数组的最后一个元素是根节点，左边的值都小于它，后边的值都大于它，然后递归的进行判断
 
 面试题34：二叉树中和为某一值的路径：
 
 思路：采用前序遍历的方法，每次先判断该节点是否是叶子节点并且路径累加和
是否=目标值，否则，前序遍历左子节点，右子节点。然后退出该节点时，需要将该
节点从路径栈中删除。

#分而治之的思想：
面试题35：复杂链表的复制
一个链表即每个节点中即有next指针，同时又一个sibling指针，指向一个随机节点。

思路：首先在每个节点后面复制一个节点，然后，然后连接sibling节点，因为若s = N.sibling，则
s.next（s'）.sibling = n.next(n')第三部就是分解两个链表了。
该方法很好。

然后一种另外思路就是构建一个（n，n'）和（s，s'）的哈希表，这样n'的sibling指向就是s'，该节点存在了哈希表中。

面试题36：二叉搜索树与双向链表
将一个二叉搜索树转换成一个双向链表

思路：采用中序遍历的思想，用一个指针记录遍历序列的最后一个节点，在中序处理中
将该节点的right指针指向该节点，同时将该节点的left指向它，然后递归的遍历左子树和
右子树即可。
最后从last节点从左至右的去遍历该双向链表并返回头结点。

面试题37：序列化与反序列化

采用前序遍历的方式，将一个二叉树读入字符串中，空指针为null，反序列化的过程就是相反。
如果采用后序或者中序的方式可能不能解决问题。

#第五章 优化时间和空间效率

 面试题39：数组中出现次数超过一半的数字：
 
 方法一：采用基于Partition的思想：
 
 如果一个数字在数组中次数超过一半，那么排序的时候一定是在中位数
 ，采用partition找中位数，如果找到的下标大于mid，则中位数在index左边，end = index-1
然后在读一遍这个数组，判断该数字是否出现次数大于一半。

方法二：
用1个变量存之前访问的数字，用一个num存该数字的个数。最后判断一下
num为1的值在数组中出现的次数。


面试题40：最小的k个数
方法一：基于partition，时间复杂度O（n）,但是会修改输入数组。

方法二：时间复杂度为O（nlogk）,需要使用红黑数或者最大堆，来用O（1）时间找到
最大值，以及用Log（k）时间完成插入和删除元素。

面试题43:1-n中1出现的次数

思路：从数字规律中提高实践效率，统计每一位可能出现数字1的次数，然后去掉最高位，进行递归。

面试题44：数字序列中某一位的数字：
数字以0123456789101112这样的格式存到一个字符串数组中了，然后求出
第n位对应的数字


思路：
1位数共10个，10-99共2*90个，100-999共3*900个，比如1001位是第几位，
1001>10,所以不可能是一位数，1001-10=991，从10-99开始去找，991-2*90=811
，不可能在二位数中，881-3*900小于0，所以肯定在三位数中，然后881/3 =270 ,mod =1，所以881是
从100开始的第270个数字，也就是370，然后去370中走1得到7。

面试题48：最长不含重复字符的子字符串

思路：
采用动态规划的思想，用f（i）来表示以i字符为结尾的最长的子字符串

分两种情况讨论，（1）a（i）为出现在之前的字符串中，则f（i） = f（i-1）+1
（2）a（i）出现在之前的字符串中，则计算上一次到这一次的距离，记为d，如果d大于f（i-1），
则f（i） = f（i-1）+1，否则f（i） = f（i-1）

#5.3空间效率和时间效率的平衡
 
 面试题49：丑数
 丑数是只因子中只包好2,3,5的数字
 
 思路：
 先保存一个只有部分排好序的丑数数组，然后找到第一个乘以2大于当前
 丑数数组的数字，记为T2，第一个乘以3大于最大值得数字，记为T3，乘以5得到第一个大于当前最大值的
 数字T5，保存三者的最小值到数组中，执行n次。
 
 面试题50：第一个只出现一次的字符
 
 思路：定义一个哈希表，遍历两次该表即可。第一次统计每个字符出现的次数
 第二次访问第一次次数为1的字符。python中其实可以用list来简易的实现。
 
 面试题51：统计数组中的逆序对：
 
 思路：采用归并排序的思想。将数组分成左右两部分，统计左边的逆序数和右边的逆序数，
 加上组间的逆序数即可。一遍排序一遍统计。
 
 #第五章总结：空间换取时间、partition函数、动态规划
 
 面试题53：在排序数组中查找数字
 查找排序数组中数字出现的次数
 
 思路：
 利用两个二分查找算法函数，一个得到第一个K，一个得到第二个K，在用坐标相减即可。
 具体得到第一个k值，如果满足中间元素等于k但前一个元素等于k，继续往前半区查找。
 
 题目二：0-n-1中缺失的数字
 
 思路：用二分查找法解决，如果一个数字和它的下标相等，则往后半区查找，如果和它得下标不等并且前一个元素和它的
 下标也不等，往前半区查找，如果和它的下标不等，并且前一个元素和它的下标相等，则返回该元素。
 
 题目三：排序数组中下标和数字相等的元素。
 
 思路：二分查找，如果一个元素值大于下标，那么它后面的元素也是这样，去前半区查找。
 元素值小于下标，它前面的元素的值也是小于下标，去后半区查找。
 
 面试题55：
 判断一个树是否是平衡二叉树
 
 思路：
 采用后序遍历的思想，先得到左子节点的深度，然后得到右子节点的深度，
 然后就可以递归的判断它是不是平衡二叉树
 
 面试题56：数组中数字出现的次数
 
 题目一：数组中出现一次的两个数字
 
 思路：如果只要求1个出现一次的数字，那么直接将整个数组的元组求异或
 就行了，因为一个元素对自己求异或等于0，最后只剩下出现一次的元素。
 如果数组中出现了两个出现1次的数字，那么首先还是对整个数组元素求异或，
 然后根据结果数字的从右至左第一个为1位，对原数组进行分组，这样分组两个出现
 1次的数字肯定分到了两个数组中，且相同的数组也是分到了同一个数组中，再分别对两个数组进行异或就ok了。
 
 题目2：除了一个数字出现了一次，其余的数字都出现了3次
 将数组中每一位数字的二级制位加起来，如果结果中某一位的和能整除3，那么那个
 只出现一次的数字对应位置为0，否则为1。
 
 面试题57：和为s的数字

 
 题目一：和为s的两个数字
 
 数组为排序好的数组，所以很简单，设置两个指针begin和end，两个指针大了，减小end
 指针下标，小了增大begin指针坐标
 
 题目2：和为s的连续正数序列
 
 思路，采用跟前面相似的思路
 
 设置small为1，big =2，如果当前和小了，增大big的范围，如果大了，增加small的下标。
 
 面试题59：队列的最大值
 
 题目描述：给定一个数组和滑动窗口的大小，请找出所有滑动窗口里的最大值
 
 思路：用一个双端队列来实现它，这个队列的队头总是保存滑动窗口的最大值
 如果待存数字大于双端队列队尾元素，逐个地删除队尾元素，否则存入待存元素。
 该双端队列中存入的是元素的下标，用来判断某个队列中的元素是否已经滑出
 窗口。
 
 实现队列的最大值也可以用这个双端队列来实现。
 
 面试题62：圆圈中最后剩下的数字：
 
 可以采用环形列表的方式来访问，也可以用数学归纳法推理出它的公式
 
 F(n,m)表示从n个数字中每次删除第m个数字后最后剩下的数字
 f（n,m） = 0,如果n==1，n>1时，f（n，m）= （f（n-1，m）+m）%n
 
 写成循环的形式就是 int last =0, for int i =2,i<=n,i++,last = (last+m)%i
 
 面试题63：股票的最大利润
 
 只要用一个min变量记录访问到的前i-1个变量的最小值，然后用当前变量减去它得到以i结尾的最大
 利润，然后与max进行比较就ok了。
 
 面试题65：不用加减乘除做加法
 
 写一个函数，求两个数之和，不得使用加减乘除
 
 思路：那肯定只能用位运算了
 
 一个数字与另一个数字做异或运算，那么得到的数字是各位数字之和，但是没有加上进位，
 一个数与另一个数做与运算，那么0+0、0+1、1+0均不产生进位，结果为0，只有1+1是1，但是
不要左移一位。然后继续利用得到的两个数字进行运算即可，只能得到的sum，也就是与运算结果为0，不产生进位。 
 